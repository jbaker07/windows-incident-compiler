//! Copilot Service: Renders compiler state into natural language with citations.
//!
//! The Copilot NEVER decides incidents, NEVER invents facts, and NEVER provides
//! exploit/flag/walkthrough instructions. It only explains what the compiler has
//! determined, always with evidence citations.

use super::canonical_event::EvidencePtr;
use super::disambiguator::{Disambiguator, PivotAction};
use super::explanation::{Claim, ClaimCertainty, ExplanationResponse, MissingReason};
use super::promotion::Severity;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

// ============================================================================
// Copilot Answer Structure
// ============================================================================

/// Output format preference
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum OutputFormat {
    /// Short, concise answer
    Short,
    /// Detailed explanation
    #[default]
    Detailed,
    /// Full report format
    Report,
    /// Bullet points
    Bullets,
}

/// Citation linking a claim to its evidence
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Citation {
    /// Citation token (e.g., "[E1]")
    pub token: String,
    /// Claim ID from ExplanationResponse
    pub claim_id: String,
    /// Evidence pointers for this claim
    pub evidence_ptrs: Vec<EvidencePtr>,
    /// Brief description for tooltip
    pub description: String,
}

/// Suggested pivot action for the UI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuggestedPivot {
    /// Disambiguator ID
    pub disambiguator_id: String,
    /// Human-readable label for button
    pub label: String,
    /// Action type for UI rendering
    pub action_type: String,
    /// Parameters for the pivot
    pub params: HashMap<String, serde_json::Value>,
}

/// Uncertainty flag when visibility gaps exist
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UncertaintyFlag {
    /// Type of uncertainty
    pub flag_type: UncertaintyType,
    /// Description
    pub description: String,
    /// Affected analysis areas
    pub affected_areas: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum UncertaintyType {
    /// Sensor/stream not present
    SensorMissing,
    /// Event not observed but sensor present
    NotObserved,
    /// Visibility gap in time
    VisibilityGap,
    /// Evidence integrity issue
    IntegrityIssue,
    /// Insufficient corroboration
    InsufficientCorroboration,
}

/// Complete copilot answer
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CopilotAnswer {
    /// Natural language answer text (with citation tokens like [E1])
    pub text: String,

    /// All citations referenced in text
    pub citations: Vec<Citation>,

    /// Suggested pivot actions
    pub suggested_pivots: Vec<SuggestedPivot>,

    /// Uncertainty flags if visibility gaps present
    pub uncertainty_flags: Vec<UncertaintyFlag>,

    /// Whether this was generated by templated fallback
    pub is_templated_fallback: bool,

    /// Generation timestamp
    pub generated_at: DateTime<Utc>,

    /// Output format used
    pub format: OutputFormat,
}

impl CopilotAnswer {
    pub fn new(text: String) -> Self {
        Self {
            text,
            citations: Vec::new(),
            suggested_pivots: Vec::new(),
            uncertainty_flags: Vec::new(),
            is_templated_fallback: false,
            generated_at: Utc::now(),
            format: OutputFormat::Detailed,
        }
    }

    pub fn templated(text: String) -> Self {
        Self {
            text,
            citations: Vec::new(),
            suggested_pivots: Vec::new(),
            uncertainty_flags: Vec::new(),
            is_templated_fallback: true,
            generated_at: Utc::now(),
            format: OutputFormat::Detailed,
        }
    }

    pub fn with_citations(mut self, citations: Vec<Citation>) -> Self {
        self.citations = citations;
        self
    }

    pub fn with_pivots(mut self, pivots: Vec<SuggestedPivot>) -> Self {
        self.suggested_pivots = pivots;
        self
    }

    pub fn with_uncertainty(mut self, flags: Vec<UncertaintyFlag>) -> Self {
        self.uncertainty_flags = flags;
        self
    }

    pub fn with_format(mut self, format: OutputFormat) -> Self {
        self.format = format;
        self
    }
}

// ============================================================================
// Copilot Request
// ============================================================================

/// Request to the copilot service
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CopilotRequest {
    pub session_id: Option<String>,
    pub question: String,
    pub output_format: OutputFormat,
    pub context: Option<CopilotContext>,
}

/// Additional context for copilot
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CopilotContext {
    /// Platform context (e.g., "htb", "thm", "production")
    pub platform_context: Option<String>,
    /// User verbosity preference (0-2)
    pub verbosity: Option<u8>,
    /// Preferred citation density (low/medium/high)
    pub citation_density: Option<String>,
}

// ============================================================================
// Validation
// ============================================================================

/// Validation result for copilot output
#[derive(Debug, Clone)]
pub struct ValidationResult {
    pub valid: bool,
    pub errors: Vec<ValidationError>,
}

#[derive(Debug, Clone)]
pub struct ValidationError {
    pub error_type: ValidationErrorType,
    pub message: String,
}

#[derive(Debug, Clone)]
pub enum ValidationErrorType {
    NonExistentClaimId,
    NonExistentEvidencePtr,
    NonExistentDisambiguator,
    UngroundedClaim,
    ForbiddenContent,
}

/// Validate copilot output against ExplanationResponse
pub fn validate_copilot_output(
    answer: &CopilotAnswer,
    explanation: &ExplanationResponse,
) -> ValidationResult {
    let mut errors = Vec::new();

    // Build valid sets
    let valid_claim_ids: HashSet<_> = explanation
        .observed_claims
        .iter()
        .map(|c| c.claim_id.as_str())
        .collect();

    let valid_disambiguator_ids: HashSet<_> = explanation
        .disambiguators
        .iter()
        .map(|d| d.id.as_str())
        .collect();

    // Validate citations
    for citation in &answer.citations {
        if !valid_claim_ids.contains(citation.claim_id.as_str()) {
            errors.push(ValidationError {
                error_type: ValidationErrorType::NonExistentClaimId,
                message: format!(
                    "Claim ID '{}' not found in ExplanationResponse",
                    citation.claim_id
                ),
            });
        }
    }

    // Validate pivots
    for pivot in &answer.suggested_pivots {
        if !valid_disambiguator_ids.contains(pivot.disambiguator_id.as_str()) {
            errors.push(ValidationError {
                error_type: ValidationErrorType::NonExistentDisambiguator,
                message: format!(
                    "Disambiguator ID '{}' not found in ExplanationResponse",
                    pivot.disambiguator_id
                ),
            });
        }
    }

    // Check for forbidden content patterns
    let forbidden_patterns = [
        "try this command",
        "run this",
        "execute the following",
        "flag is",
        "the flag:",
        "htb{",
        "thm{",
        "ctf{",
        "exploit this",
        "attack the",
    ];

    let text_lower = answer.text.to_lowercase();
    for pattern in forbidden_patterns {
        if text_lower.contains(pattern) {
            errors.push(ValidationError {
                error_type: ValidationErrorType::ForbiddenContent,
                message: format!("Forbidden pattern detected: '{}'", pattern),
            });
        }
    }

    ValidationResult {
        valid: errors.is_empty(),
        errors,
    }
}

// ============================================================================
// Precomputed Context for Model
// ============================================================================

/// Precomputed context to ground the model
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GroundingContext {
    /// Claim ID â†’ Evidence PTRs mapping
    pub claim_evidence_map: HashMap<String, Vec<EvidencePtr>>,
    /// Top 3 hypotheses with reasons
    pub top3_summary: Vec<HypothesisSummaryForCopilot>,
    /// Missing required slots
    pub missing_required_slots: Vec<String>,
    /// Visibility summary
    pub visibility_summary: VisibilitySummary,
    /// Available disambiguators
    pub available_pivots: Vec<PivotSummary>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HypothesisSummaryForCopilot {
    pub rank: u8,
    pub family: String,
    pub template_id: String,
    pub maturity: f64,
    pub confidence: f64,
    pub severity: Severity,
    pub why_wins: String,
    pub slots_satisfied: String,
    pub key_evidence: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VisibilitySummary {
    pub streams_present: Vec<String>,
    pub streams_missing: Vec<String>,
    pub is_degraded: bool,
    pub degraded_explanation: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PivotSummary {
    pub id: String,
    pub action_type: String,
    pub description: String,
}

/// Build grounding context from ExplanationResponse
pub fn build_grounding_context(explanation: &ExplanationResponse) -> GroundingContext {
    // Build claim â†’ evidence map
    let mut claim_evidence_map = HashMap::new();
    for claim in &explanation.observed_claims {
        claim_evidence_map.insert(claim.claim_id.clone(), claim.evidence_ptrs.clone());
    }

    // Build top3 summary
    let mut top3_summary = Vec::new();
    if let Some(ref arb) = explanation.top3_hypotheses {
        for (i, ranked) in arb.top3.iter().enumerate() {
            top3_summary.push(HypothesisSummaryForCopilot {
                rank: (i + 1) as u8,
                family: ranked.family.clone(),
                template_id: ranked.template_id.clone(),
                maturity: ranked.maturity,
                confidence: ranked.confidence,
                severity: ranked.severity,
                why_wins: ranked.why_wins.join("; "),
                slots_satisfied: format!(
                    "{}/{} required",
                    ranked.required_satisfied, ranked.required_total
                ),
                key_evidence: ranked
                    .key_evidence_ptrs
                    .iter()
                    .take(3)
                    .map(|p| format!("{}:{}", p.stream_id, p.record_index))
                    .collect(),
            });
        }
    }

    // Missing required slots
    let missing_required_slots: Vec<String> = explanation
        .missing_evidence
        .iter()
        .map(|m| m.slot_name.clone())
        .collect();

    // Visibility summary
    let visibility_summary = VisibilitySummary {
        streams_present: explanation.visibility_state.streams_present.clone(),
        streams_missing: explanation.visibility_state.streams_missing.clone(),
        is_degraded: explanation.visibility_state.degraded,
        degraded_explanation: if explanation.visibility_state.degraded {
            Some(explanation.visibility_state.degraded_reasons.join("; "))
        } else {
            None
        },
    };

    // Available pivots
    let available_pivots: Vec<PivotSummary> = explanation
        .disambiguators
        .iter()
        .map(|d| PivotSummary {
            id: d.id.clone(),
            action_type: format!("{:?}", d.action),
            description: d.rationale.clone(),
        })
        .collect();

    GroundingContext {
        claim_evidence_map,
        top3_summary,
        missing_required_slots,
        visibility_summary,
        available_pivots,
    }
}

// ============================================================================
// Templated Renderer (Mandatory Fallback)
// ============================================================================

/// Templated renderer for guaranteed output even if model fails
pub struct TemplatedRenderer {
    /// Citation counter for generating tokens
    #[allow(dead_code)]
    citation_counter: usize,
    /// Generated citations
    citations: Vec<Citation>,
}

impl TemplatedRenderer {
    pub fn new() -> Self {
        Self {
            citation_counter: 0,
            citations: Vec::new(),
        }
    }

    /// Generate next citation token
    #[allow(dead_code)]
    fn next_citation(&mut self, claim: &Claim) -> String {
        self.citation_counter += 1;
        let token = format!("[E{}]", self.citation_counter);
        self.citations.push(Citation {
            token: token.clone(),
            claim_id: claim.claim_id.clone(),
            evidence_ptrs: claim.evidence_ptrs.clone(),
            description: truncate(&claim.text, 80),
        });
        token
    }

    /// Render complete answer from ExplanationResponse
    pub fn render(
        &mut self,
        explanation: &ExplanationResponse,
        format: OutputFormat,
    ) -> CopilotAnswer {
        let mut sections = Vec::new();

        // 1. Top 3 hypotheses summary
        if let Some(section) = self.render_top3_hypotheses(explanation) {
            sections.push(section);
        }

        // 2. Why not an incident yet (if applicable)
        if let Some(section) = self.render_not_promoted_reason(explanation) {
            sections.push(section);
        }

        // 3. Visibility gaps
        if let Some(section) = self.render_visibility_gaps(explanation) {
            sections.push(section);
        }

        // 4. Integrity notes
        if let Some(section) = self.render_integrity_notes(explanation) {
            sections.push(section);
        }

        // 5. Next pivots
        let pivots = self.render_suggested_pivots(explanation);

        // 6. Uncertainty flags
        let uncertainty_flags = self.build_uncertainty_flags(explanation);

        // Combine sections based on format
        let text = match format {
            OutputFormat::Short => self.format_short(&sections),
            OutputFormat::Detailed => self.format_detailed(&sections),
            OutputFormat::Report => self.format_report(&sections, explanation),
            OutputFormat::Bullets => self.format_bullets(&sections),
        };

        CopilotAnswer::templated(text)
            .with_citations(std::mem::take(&mut self.citations))
            .with_pivots(pivots)
            .with_uncertainty(uncertainty_flags)
            .with_format(format)
    }

    /// Render top 3 hypotheses section
    fn render_top3_hypotheses(&mut self, explanation: &ExplanationResponse) -> Option<String> {
        let arb = explanation.top3_hypotheses.as_ref()?;
        if arb.top3.is_empty() {
            return Some("No hypotheses are currently active for this scope.".to_string());
        }

        let mut lines = vec!["## Top Hypotheses\n".to_string()];

        for (i, ranked) in arb.top3.iter().enumerate() {
            let rank = i + 1;
            let severity_icon = match ranked.severity {
                Severity::Critical => "ðŸ”´",
                Severity::High => "ðŸŸ ",
                Severity::Medium => "ðŸŸ¡",
                Severity::Low => "ðŸŸ¢",
                Severity::Informational => "âšª",
            };

            lines.push(format!(
                "**#{} {} {}** (Confidence: {:.0}%, Maturity: {:.0}%)",
                rank,
                severity_icon,
                ranked.family.replace('_', " ").to_uppercase(),
                ranked.confidence * 100.0,
                ranked.maturity * 100.0,
            ));

            // Slots status
            lines.push(format!(
                "  - Slots: {}/{} required satisfied",
                ranked.required_satisfied, ranked.required_total
            ));

            // Why wins (if available)
            if !ranked.why_wins.is_empty() {
                lines.push(format!(
                    "  - Ranking rationale: {}",
                    ranked.why_wins.join("; ")
                ));
            }

            // Key evidence with citations
            if !ranked.key_evidence_ptrs.is_empty() {
                let evidence_refs: Vec<String> = ranked
                    .key_evidence_ptrs
                    .iter()
                    .take(2)
                    .map(|ptr| format!("{}:{}", ptr.stream_id, ptr.record_index))
                    .collect();
                lines.push(format!("  - Key evidence: {}", evidence_refs.join(", ")));
            }

            lines.push(String::new());
        }

        // Absorption note if applicable
        if !arb.absorbed.is_empty() {
            lines.push(format!(
                "*{} lower-ranked hypotheses were absorbed into higher-ranked ones.*\n",
                arb.absorbed.len()
            ));
        }

        Some(lines.join("\n"))
    }

    /// Render "not promoted" explanation
    fn render_not_promoted_reason(&mut self, explanation: &ExplanationResponse) -> Option<String> {
        // Check if top hypothesis is not an incident
        let arb = explanation.top3_hypotheses.as_ref()?;
        let top = arb.top3.first()?;

        // If promoted, no need for this section
        if top.maturity >= 0.85 && top.confidence >= 0.7 {
            return None;
        }

        let mut lines = vec!["## Why Not an Incident Yet\n".to_string()];

        // Missing required slots
        if !explanation.missing_evidence.is_empty() {
            lines.push("**Missing Required Evidence:**".to_string());
            for missing in &explanation.missing_evidence {
                let reason = match &missing.reason {
                    MissingReason::StreamMissing { stream_id } => {
                        format!("sensor '{}' not present", stream_id)
                    }
                    MissingReason::NotObserved => "not observed (sensor present)".to_string(),
                    MissingReason::OutsideWindow => "outside current time window".to_string(),
                    MissingReason::VisibilityGap { description } => {
                        format!("visibility gap: {}", description)
                    }
                };
                lines.push(format!("  - **{}**: {}", missing.slot_name, reason));
            }
            lines.push(String::new());
        }

        // Maturity explanation
        if top.maturity < 0.85 {
            lines.push(format!(
                "**Maturity Score ({:.0}%)**: Below 85% threshold. This means not enough corroborating \
                evidence from independent sources has been observed.",
                top.maturity * 100.0
            ));
        }

        // Confidence explanation
        if top.confidence < 0.7 {
            lines.push(format!(
                "**Confidence Score ({:.0}%)**: Reduced due to visibility gaps or ambiguous evidence.",
                top.confidence * 100.0
            ));
        }

        Some(lines.join("\n"))
    }

    /// Render visibility gaps section
    fn render_visibility_gaps(&mut self, explanation: &ExplanationResponse) -> Option<String> {
        if !explanation.visibility_state.degraded {
            return None;
        }

        let mut lines = vec!["## Visibility Gaps\n".to_string()];

        lines.push("âš ï¸ **Analysis is limited due to missing telemetry streams.**\n".to_string());

        if !explanation.visibility_state.streams_missing.is_empty() {
            lines.push("**Missing Streams:**".to_string());
            for stream in &explanation.visibility_state.streams_missing {
                let impact = stream_impact_description(stream);
                lines.push(format!("  - `{}`: {}", stream, impact));
            }
            lines.push(String::new());
        }

        lines.push(
            "**Important:** \"Not observed\" does not mean \"didn't happen\". \
            It means the evidence was not available to the sensors.\n"
                .to_string(),
        );

        // Degraded reasons
        if !explanation.visibility_state.degraded_reasons.is_empty() {
            lines.push("**Reasons:**".to_string());
            for reason in &explanation.visibility_state.degraded_reasons {
                lines.push(format!("  - {}", reason));
            }
        }

        Some(lines.join("\n"))
    }

    /// Render integrity notes section
    fn render_integrity_notes(&mut self, explanation: &ExplanationResponse) -> Option<String> {
        if explanation.integrity_notes.is_empty() {
            return None;
        }

        let mut lines = vec!["## Evidence Integrity Notes\n".to_string()];

        for note in &explanation.integrity_notes {
            let icon = match note.severity {
                super::explanation::IntegrityNoteSeverity::Error => "âŒ",
                super::explanation::IntegrityNoteSeverity::Warning => "âš ï¸",
            };
            lines.push(format!(
                "{} **{:?}**: {}",
                icon, note.note_type, note.description
            ));
        }

        lines.push(String::new());
        lines.push(
            "*Claims based on evidence with integrity issues should be treated with lower confidence.*"
                .to_string(),
        );

        Some(lines.join("\n"))
    }

    /// Render suggested pivots
    fn render_suggested_pivots(&self, explanation: &ExplanationResponse) -> Vec<SuggestedPivot> {
        explanation
            .disambiguators
            .iter()
            .map(|d| {
                let (label, action_type) = disambiguator_to_ui(d);
                SuggestedPivot {
                    disambiguator_id: d.id.clone(),
                    label,
                    action_type,
                    params: d.parameters.clone().unwrap_or_default(),
                }
            })
            .collect()
    }

    /// Build uncertainty flags
    fn build_uncertainty_flags(&self, explanation: &ExplanationResponse) -> Vec<UncertaintyFlag> {
        let mut flags = Vec::new();

        // Missing streams
        for stream in &explanation.visibility_state.streams_missing {
            flags.push(UncertaintyFlag {
                flag_type: UncertaintyType::SensorMissing,
                description: format!("Stream '{}' is not available", stream),
                affected_areas: vec![stream_to_analysis_area(stream)],
            });
        }

        // Integrity issues
        for note in &explanation.integrity_notes {
            flags.push(UncertaintyFlag {
                flag_type: UncertaintyType::IntegrityIssue,
                description: note.description.clone(),
                affected_areas: note
                    .affected_evidence_ptrs
                    .iter()
                    .map(|s| s.to_string())
                    .collect(),
            });
        }

        // Missing evidence (not observed)
        for missing in &explanation.missing_evidence {
            if matches!(missing.reason, MissingReason::NotObserved) {
                flags.push(UncertaintyFlag {
                    flag_type: UncertaintyType::NotObserved,
                    description: format!(
                        "Expected '{}' was not observed (sensor present)",
                        missing.slot_name
                    ),
                    affected_areas: vec![missing.slot_name.clone()],
                });
            }
        }

        flags
    }

    /// Format for short output
    fn format_short(&self, sections: &[String]) -> String {
        // Take first non-empty section or summary
        sections
            .first()
            .map(|s| {
                // Truncate to first paragraph
                s.split("\n\n")
                    .next()
                    .unwrap_or(s)
                    .replace("## ", "")
                    .trim()
                    .to_string()
            })
            .unwrap_or_else(|| "No significant findings.".to_string())
    }

    /// Format for detailed output
    fn format_detailed(&self, sections: &[String]) -> String {
        sections.join("\n---\n\n")
    }

    /// Format for report output
    fn format_report(&self, sections: &[String], explanation: &ExplanationResponse) -> String {
        let mut report = vec![
            "# Incident Analysis Report\n".to_string(),
            format!(
                "**Generated:** {}\n",
                explanation.generated_ts.format("%Y-%m-%d %H:%M:%S UTC")
            ),
            format!("**Host:** {}\n", explanation.query_context.host_id),
        ];

        // Executive summary
        report.push("## Executive Summary\n".to_string());
        report.push(self.format_short(sections));
        report.push(String::new());

        // Full sections
        for section in sections {
            report.push(section.clone());
            report.push(String::new());
        }

        // Timeline if available
        if !explanation.timeline.is_empty() {
            report.push("## Timeline\n".to_string());
            for entry in &explanation.timeline {
                report.push(format!(
                    "- **{}**: {}",
                    entry.ts.format("%H:%M:%S"),
                    entry.summary
                ));
            }
            report.push(String::new());
        }

        // Claims appendix
        report.push("## Evidence Claims\n".to_string());
        for claim in &explanation.observed_claims {
            let certainty = match claim.certainty {
                ClaimCertainty::Observed => "Observed",
                ClaimCertainty::InferredFromRules => "Inferred",
                ClaimCertainty::Unknown => "Unknown",
            };
            report.push(format!(
                "- [{}] {} ({})",
                claim.claim_id, claim.text, certainty
            ));
        }

        report.join("\n")
    }

    /// Format for bullet output
    fn format_bullets(&self, sections: &[String]) -> String {
        let mut bullets = Vec::new();
        for section in sections {
            for line in section.lines() {
                let trimmed = line.trim();
                if !trimmed.is_empty() && !trimmed.starts_with('#') {
                    // Convert to bullet if not already
                    if trimmed.starts_with('-') || trimmed.starts_with('*') {
                        bullets.push(trimmed.to_string());
                    } else if trimmed.starts_with("**") {
                        bullets.push(format!("â€¢ {}", trimmed));
                    }
                }
            }
        }
        bullets.join("\n")
    }
}

impl Default for TemplatedRenderer {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================================
// Question Handlers (Deterministic)
// ============================================================================

/// Categorize user question
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum QuestionCategory {
    WhatHappened,
    WhyNotIncident,
    WhatChanged,
    ExplainHypothesis,
    ExplainVisibility,
    SuggestNextSteps,
    GenerateReport,
    Other,
}

/// Categorize the user's question for targeted rendering
pub fn categorize_question(question: &str) -> QuestionCategory {
    let q = question.to_lowercase();

    if q.contains("what happened") || q.contains("what's going on") || q.contains("summarize") {
        QuestionCategory::WhatHappened
    } else if q.contains("why not") || q.contains("not an incident") || q.contains("not promoted") {
        QuestionCategory::WhyNotIncident
    } else if q.contains("what changed") || q.contains("since checkpoint") || q.contains("diff") {
        QuestionCategory::WhatChanged
    } else if q.contains("explain") && (q.contains("hypothesis") || q.contains("detection")) {
        QuestionCategory::ExplainHypothesis
    } else if q.contains("visibility") || q.contains("missing") || q.contains("sensor") {
        QuestionCategory::ExplainVisibility
    } else if q.contains("next") || q.contains("suggest") || q.contains("pivot") || q.contains("do")
    {
        QuestionCategory::SuggestNextSteps
    } else if q.contains("report") || q.contains("document") || q.contains("pdf") {
        QuestionCategory::GenerateReport
    } else {
        QuestionCategory::Other
    }
}

/// Answer specific question categories
pub fn answer_question(
    question: &str,
    explanation: &ExplanationResponse,
    format: OutputFormat,
) -> CopilotAnswer {
    let category = categorize_question(question);
    let mut renderer = TemplatedRenderer::new();

    match category {
        QuestionCategory::WhatHappened => renderer.render(explanation, format),
        QuestionCategory::WhyNotIncident => {
            render_why_not_incident(&mut renderer, explanation, format)
        }
        QuestionCategory::ExplainVisibility => {
            render_visibility_explanation(&mut renderer, explanation, format)
        }
        QuestionCategory::SuggestNextSteps => render_next_steps(&mut renderer, explanation, format),
        QuestionCategory::GenerateReport => renderer.render(explanation, OutputFormat::Report),
        _ => renderer.render(explanation, format),
    }
}

fn render_why_not_incident(
    renderer: &mut TemplatedRenderer,
    explanation: &ExplanationResponse,
    format: OutputFormat,
) -> CopilotAnswer {
    let mut text = String::new();

    // Check if there's a top hypothesis
    if let Some(ref arb) = explanation.top3_hypotheses {
        if let Some(top) = arb.top3.first() {
            text.push_str(&format!(
                "The top hypothesis is **{}** with {:.0}% maturity and {:.0}% confidence.\n\n",
                top.family.replace('_', " "),
                top.maturity * 100.0,
                top.confidence * 100.0,
            ));

            // Missing slots
            if !explanation.missing_evidence.is_empty() {
                text.push_str("**Missing required evidence:**\n");
                for missing in &explanation.missing_evidence {
                    text.push_str(&format!("- {}: {:?}\n", missing.slot_name, missing.reason));
                }
                text.push('\n');
            }

            // Threshold explanation
            if top.maturity < 0.85 {
                text.push_str(&format!(
                    "Maturity ({:.0}%) is below the 85% promotion threshold. \
                    This requires more corroborating evidence from independent sources.\n",
                    top.maturity * 100.0
                ));
            }
        }
    } else {
        text.push_str("No active hypotheses in the current scope.\n");
    }

    let pivots = renderer.render_suggested_pivots(explanation);
    let flags = renderer.build_uncertainty_flags(explanation);

    CopilotAnswer::templated(text)
        .with_pivots(pivots)
        .with_uncertainty(flags)
        .with_format(format)
}

fn render_visibility_explanation(
    renderer: &mut TemplatedRenderer,
    explanation: &ExplanationResponse,
    format: OutputFormat,
) -> CopilotAnswer {
    let mut text = String::new();

    text.push_str("## Visibility Analysis\n\n");

    if explanation.visibility_state.degraded {
        text.push_str("âš ï¸ **Visibility is degraded.**\n\n");
    } else {
        text.push_str("âœ… **All expected streams are present.**\n\n");
    }

    // Present streams
    if !explanation.visibility_state.streams_present.is_empty() {
        text.push_str("**Active Streams:**\n");
        for stream in &explanation.visibility_state.streams_present {
            text.push_str(&format!("- âœ“ `{}`\n", stream));
        }
        text.push('\n');
    }

    // Missing streams
    if !explanation.visibility_state.streams_missing.is_empty() {
        text.push_str("**Missing Streams:**\n");
        for stream in &explanation.visibility_state.streams_missing {
            text.push_str(&format!(
                "- âœ— `{}`: {}\n",
                stream,
                stream_impact_description(stream)
            ));
        }
        text.push('\n');
    }

    text.push_str(
        "\n**Key distinction:**\n\
        - \"Not observed\" = sensor was active but didn't see the event\n\
        - \"Sensor missing\" = we cannot make claims about this data\n",
    );

    let pivots = renderer.render_suggested_pivots(explanation);
    let flags = renderer.build_uncertainty_flags(explanation);

    CopilotAnswer::templated(text)
        .with_pivots(pivots)
        .with_uncertainty(flags)
        .with_format(format)
}

fn render_next_steps(
    renderer: &mut TemplatedRenderer,
    explanation: &ExplanationResponse,
    format: OutputFormat,
) -> CopilotAnswer {
    let mut text = String::new();

    text.push_str("## Suggested Next Steps\n\n");

    if explanation.disambiguators.is_empty() {
        text.push_str("No specific pivots are recommended at this time.\n");
    } else {
        text.push_str("Based on the current analysis, consider these actions:\n\n");

        for (i, disambiguator) in explanation.disambiguators.iter().enumerate() {
            let (label, _) = disambiguator_to_ui(disambiguator);
            text.push_str(&format!(
                "{}. **{}**\n   {}\n\n",
                i + 1,
                label,
                disambiguator.rationale
            ));
        }
    }

    let pivots = renderer.render_suggested_pivots(explanation);
    let flags = renderer.build_uncertainty_flags(explanation);

    CopilotAnswer::templated(text)
        .with_pivots(pivots)
        .with_uncertainty(flags)
        .with_format(format)
}

// ============================================================================
// Helper Functions
// ============================================================================

fn truncate(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        s.to_string()
    } else {
        format!("{}...", &s[..max_len - 3])
    }
}

fn stream_impact_description(stream: &str) -> &'static str {
    match stream {
        s if s.contains("process") || s.contains("exec") => "Process execution visibility affected",
        s if s.contains("network") || s.contains("connect") => {
            "Network connection visibility affected"
        }
        s if s.contains("file") => "File operation visibility affected",
        s if s.contains("memory") || s.contains("mprotect") => {
            "Memory operation visibility affected"
        }
        s if s.contains("registry") => "Registry operation visibility affected",
        s if s.contains("auth") => "Authentication event visibility affected",
        _ => "General visibility affected",
    }
}

fn stream_to_analysis_area(stream: &str) -> String {
    if stream.contains("process") || stream.contains("exec") {
        "Process Analysis".to_string()
    } else if stream.contains("network") || stream.contains("connect") {
        "Network Analysis".to_string()
    } else if stream.contains("file") {
        "File Analysis".to_string()
    } else if stream.contains("memory") {
        "Memory Analysis".to_string()
    } else {
        "General Analysis".to_string()
    }
}

fn disambiguator_to_ui(d: &Disambiguator) -> (String, String) {
    match &d.action {
        PivotAction::ExpandWindowBackward { seconds } => (
            format!("Expand window -{} min", seconds / 60),
            "expand_window".to_string(),
        ),
        PivotAction::ExpandWindowForward { seconds } => (
            format!("Expand window +{} min", seconds / 60),
            "expand_window".to_string(),
        ),
        PivotAction::FocusEntity { scope_key } => (
            format!("Focus on {:?}", scope_key),
            "focus_entity".to_string(),
        ),
        PivotAction::FocusProcessTree { proc_key } => (
            format!("Focus process tree: {}", truncate(proc_key, 20)),
            "focus_tree".to_string(),
        ),
        PivotAction::FetchFileHash { path, .. } => (
            format!("Fetch hash: {}", truncate(path, 30)),
            "fetch_hash".to_string(),
        ),
        PivotAction::JoinSockToProc { sock_key } => (
            format!("Join socket to process: {}", truncate(sock_key, 20)),
            "join_sock".to_string(),
        ),
        PivotAction::QueryEvents { filter_expression } => (
            format!("Query: {}", truncate(filter_expression, 30)),
            "query".to_string(),
        ),
        PivotAction::EnableForensicBurst { ttl_seconds, .. } => (
            format!("Enable forensic burst ({}s)", ttl_seconds),
            "forensic_burst".to_string(),
        ),
        PivotAction::CrossHostCorrelation { host_ids } => {
            let target = host_ids.first().map(|s| s.as_str()).unwrap_or("unknown");
            (
                format!("Cross-host: {}", truncate(target, 20)),
                "cross_host".to_string(),
            )
        }
        PivotAction::TimelineReconstruction { start_ts, end_ts } => (
            format!("Reconstruct timeline ({}s span)", end_ts - start_ts),
            "timeline".to_string(),
        ),
        PivotAction::ParentChainExpansion { proc_key: _, depth } => (
            format!("Expand parent chain (depth {})", depth),
            "parent_chain".to_string(),
        ),
        PivotAction::ChildProcessScan { proc_key: _, depth } => (
            format!("Scan child processes (depth {})", depth),
            "child_scan".to_string(),
        ),
        PivotAction::FetchProcTree { proc_key, depth } => (
            format!(
                "Fetch process tree: {} (depth {})",
                truncate(proc_key, 15),
                depth
            ),
            "proc_tree".to_string(),
        ),
        PivotAction::RequestStream { stream_id, .. } => (
            format!("Request stream: {}", stream_id),
            "request_stream".to_string(),
        ),
        PivotAction::FetchDnsResolution { ip } => {
            (format!("Fetch DNS: {}", ip), "dns_resolution".to_string())
        }
        PivotAction::VerifySignature { path } => (
            format!("Verify signature: {}", truncate(path, 30)),
            "verify_sig".to_string(),
        ),
        PivotAction::CannotPivot { reason, .. } => (
            format!("Cannot pivot: {}", truncate(reason, 30)),
            "cannot_pivot".to_string(),
        ),
        PivotAction::None => ("No action available".to_string(), "none".to_string()),
    }
}

// ============================================================================
// Safety Constraints for HTB/THM
// ============================================================================

/// Check if platform context indicates CTF/lab environment
pub fn is_ctf_context(context: &Option<CopilotContext>) -> bool {
    context
        .as_ref()
        .and_then(|c| c.platform_context.as_ref())
        .map(|p| {
            let p = p.to_lowercase();
            p.contains("htb")
                || p.contains("hackthebox")
                || p.contains("thm")
                || p.contains("tryhackme")
        })
        .unwrap_or(false)
}

/// Apply CTF-specific safety filters
pub fn apply_ctf_safety(answer: &mut CopilotAnswer) {
    // Append safety note
    answer.text.push_str(
        "\n\n---\n*Note: In CTF/lab environments, the Copilot explains observed evidence \
        and analysis gaps. For next steps, use the suggested pivots to gather more evidence \
        rather than direct attack guidance.*",
    );
}

// ============================================================================
// Copilot Service Trait
// ============================================================================

/// Main Copilot service trait
pub trait CopilotService {
    /// Process a copilot request and produce an answer
    fn ask(
        &self,
        request: CopilotRequest,
        explanation: ExplanationResponse,
    ) -> Result<CopilotAnswer, CopilotError>;
}

#[derive(Debug, Clone)]
pub struct CopilotError {
    pub code: String,
    pub message: String,
}

impl std::fmt::Display for CopilotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CopilotError({}): {}", self.code, self.message)
    }
}

impl std::error::Error for CopilotError {}

/// Default copilot implementation using templated renderer
pub struct DefaultCopilot;

impl CopilotService for DefaultCopilot {
    fn ask(
        &self,
        request: CopilotRequest,
        explanation: ExplanationResponse,
    ) -> Result<CopilotAnswer, CopilotError> {
        // Build answer using templated renderer
        let mut answer = answer_question(&request.question, &explanation, request.output_format);

        // Validate output
        let validation = validate_copilot_output(&answer, &explanation);
        if !validation.valid {
            // Log validation errors but still return (templated is safe)
            for error in &validation.errors {
                eprintln!(
                    "Copilot validation warning: {:?} - {}",
                    error.error_type, error.message
                );
            }
        }

        // Apply CTF safety if needed
        if is_ctf_context(&request.context) {
            apply_ctf_safety(&mut answer);
        }

        Ok(answer)
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::hypothesis::explanation::QueryContext;
    use crate::hypothesis::session::SessionMode;

    #[test]
    fn test_question_categorization() {
        assert_eq!(
            categorize_question("What happened on this host?"),
            QuestionCategory::WhatHappened
        );
        assert_eq!(
            categorize_question("Why is this not an incident?"),
            QuestionCategory::WhyNotIncident
        );
        assert_eq!(
            categorize_question("What changed since my last checkpoint?"),
            QuestionCategory::WhatChanged
        );
        assert_eq!(
            categorize_question("Explain the visibility gaps"),
            QuestionCategory::ExplainVisibility
        );
        assert_eq!(
            categorize_question("What should I do next?"),
            QuestionCategory::SuggestNextSteps
        );
    }

    #[test]
    fn test_ctf_context_detection() {
        let htb_context = Some(CopilotContext {
            platform_context: Some("htb-machine".to_string()),
            verbosity: None,
            citation_density: None,
        });
        assert!(is_ctf_context(&htb_context));

        let prod_context = Some(CopilotContext {
            platform_context: Some("production".to_string()),
            verbosity: None,
            citation_density: None,
        });
        assert!(!is_ctf_context(&prod_context));

        assert!(!is_ctf_context(&None));
    }

    #[test]
    fn test_validation_forbidden_content() {
        let answer = CopilotAnswer::new("Try this command: rm -rf /".to_string());
        let explanation = ExplanationResponse::new(QueryContext {
            mode: SessionMode::Discovery,
            focus_window: None,
            focus_entities: Vec::new(),
            families_enabled: Vec::new(),
            checkpoint_ref: None,
            host_id: "test".to_string(),
            query_ts: Utc::now(),
        });

        let result = validate_copilot_output(&answer, &explanation);
        assert!(!result.valid);
        assert!(result
            .errors
            .iter()
            .any(|e| matches!(e.error_type, ValidationErrorType::ForbiddenContent)));
    }

    #[test]
    fn test_templated_renderer_basic() {
        let mut renderer = TemplatedRenderer::new();
        let explanation = ExplanationResponse::new(QueryContext {
            mode: SessionMode::Discovery,
            focus_window: None,
            focus_entities: Vec::new(),
            families_enabled: Vec::new(),
            checkpoint_ref: None,
            host_id: "test".to_string(),
            query_ts: Utc::now(),
        });

        let answer = renderer.render(&explanation, OutputFormat::Detailed);
        assert!(answer.is_templated_fallback);
    }

    #[test]
    fn test_truncate() {
        assert_eq!(truncate("short", 10), "short");
        assert_eq!(truncate("this is a long string", 10), "this is...");
    }
}
